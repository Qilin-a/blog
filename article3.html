<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript异步编程全解析 - 我的博客</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen flex flex-col">
    <!-- 导航栏 -->
    <nav class="bg-white shadow-sm sticky top-0 z-10">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <a href="index.html" class="text-xl font-bold text-blue-600">我的博客</a>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="index.html" class="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-blue-600">首页</a>
                    <a href="about.html" class="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-blue-600">关于我</a>
                </div>
            </div>
        </div>
    </nav>

    <!-- 文章内容区 -->
    <main class="flex-grow max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- 文章标题与信息 -->
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-4">JavaScript异步编程全解析</h1>
            <div class="text-gray-500 text-sm flex items-center gap-4">
                <span><i class="fa fa-calendar-o mr-1"></i> 2024年4月25日</span>
                <span><i class="fa fa-clock-o mr-1"></i> 阅读时间：10分钟</span>
                <span><i class="fa fa-comment-o mr-1"></i> <span id="comment-count">15</span>条评论</span>
            </div>
        </div>

        <!-- 文章正文 -->
        <div class="prose max-w-none text-gray-700 space-y-4 mb-12">
            <p>JavaScript作为一门单线程语言，异步编程是其核心特性之一。从早期的回调函数到现代的async/await，JavaScript的异步编程模式经历了多次演进。本文将详细解析各种异步编程模式的特点和使用场景。</p>
            
            <h2 class="text-2xl font-semibold text-gray-800 mt-8 mb-4">一、回调函数（Callbacks）</h2>
            <p>回调函数是JavaScript中最基础的异步编程方式，它是一个作为参数传递给另一个函数的函数，在某个操作完成后被调用。</p>
            
            <pre class="bg-gray-100 p-4 rounded-md text-sm"><code>// 回调函数示例
function fetchData(callback) {
  setTimeout(() => {
    const data = "一些数据";
    callback(null, data); // 第一个参数通常用于传递错误
  }, 1000);
}

// 使用回调函数
fetchData((error, result) => {
  if (error) {
    console.error("发生错误:", error);
    return;
  }
  console.log("获取到数据:", result);
});</code></pre>
            
            <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">缺点：</h3>
            <ul class="list-disc pl-5 space-y-2">
                <li>回调地狱（Callback Hell）：多个异步操作嵌套时，代码会向右缩进，难以维护</li>
                <li>错误处理复杂：每个回调都需要单独处理错误</li>
                <li>难以使用return和throw</li>
            </ul>

            <h2 class="text-2xl font-semibold text-gray-800 mt-8 mb-4">二、Promise</h2>
            <p>Promise是ES6引入的异步编程解决方案，它代表一个异步操作的最终完成（或失败）及其结果值。</p>
            
            <pre class="bg-gray-100 p-4 rounded-md text-sm"><code>// 创建Promise
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      if (success) {
        const data = "一些数据";
        resolve(data); // 成功时调用
      } else {
        reject(new Error("获取数据失败")); // 失败时调用
      }
    }, 1000);
  });
}

// 使用Promise
fetchData()
  .then(data => {
    console.log("获取到数据:", data);
    return processData(data); // 可以返回另一个Promise
  })
  .then(processedData => {
    console.log("处理后的数据:", processedData);
  })
  .catch(error => {
    console.error("发生错误:", error);
  })
  .finally(() => {
    console.log("操作完成（无论成功或失败）");
  });</code></pre>
            
            <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">优点：</h3>
            <ul class="list-disc pl-5 space-y-2">
                <li>链式调用：解决了回调地狱问题</li>
                <li>集中错误处理：一个catch可以处理链中所有错误</li>
                <li>提供了许多有用的静态方法：如Promise.all、Promise.race等</li>
            </ul>

            <h2 class="text-2xl font-semibold text-gray-800 mt-8 mb-4">三、async/await</h2>
            <p>async/await是ES2017引入的语法糖，建立在Promise之上，让异步代码看起来和同步代码一样。</p>
            
            <pre class="bg-gray-100 p-4 rounded-md text-sm"><code>// 使用async/await
async function handleData() {
  try {
    console.log("开始获取数据...");
    const data = await fetchData(); // 等待Promise完成
    console.log("获取到数据:", data);
    
    const processedData = await processData(data); // 可以链式等待
    console.log("处理后的数据:", processedData);
    
    return processedData;
  } catch (error) {
    console.error("发生错误:", error);
    // 可以在这里处理错误或重新抛出
    // throw error;
  } finally {
    console.log("操作完成");
  }
}

// 调用异步函数
handleData().then(result => {
  if (result) {
    console.log("最终结果:", result);
  }
});</code></pre>
            
            <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">优点：</h3>
            <ul class="list-disc pl-5 space-y-2">
                <li>代码更简洁，可读性更高</li>
                <li>错误处理更直观，使用try/catch即可</li>
                <li>调试更方便，可以在await处设置断点</li>
                <li>可以使用for循环等同步控制结构处理异步操作</li>
            </ul>

            <h2 class="text-2xl font-semibold text-gray-800 mt-8 mb-4">四、异步编程最佳实践</h2>
            <ul class="list-disc pl-5 space-y-2">
                <li>优先使用async/await，它是目前最优雅的异步编程方式</li>
                <li>始终处理错误，不要忽略catch或try/catch</li>
                <li>使用Promise.all处理并行异步操作，提高效率</li>
                <li>避免在循环中使用await，这会导致串行执行，降低效率</li>
                <li>理解微任务（microtasks）和宏任务（macrotasks）的执行顺序</li>
            </ul>
        </div>

        <!-- 返回首页按钮 -->
        <div class="mt-12 mb-16">
            <a href="index.html" class="inline-block px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                <i class="fa fa-arrow-left mr-1"></i> 返回首页
            </a>
        </div>

        <!-- 评论区 -->
        <div class="mt-16 border-t pt-8">
            <h2 class="text-2xl font-bold mb-6">评论区</h2>
            
            <!-- 评论表单 -->
            <div class="bg-white p-6 rounded-lg shadow-sm mb-8">
                <h3 class="text-lg font-semibold mb-4">发表评论</h3>
                <form id="comment-form" class="space-y-4">
                    <div>
                        <label for="name" class="block text-sm font-medium text-gray-700 mb-1">昵称</label>
                        <input type="text" id="name" name="name" required
                            class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="comment" class="block text-sm font-medium text-gray-700 mb-1">评论内容</label>
                        <textarea id="comment" name="comment" rows="4" required
                            class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></textarea>
                    </div>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                        提交评论
                    </button>
                </form>
            </div>
            
            <!-- 评论列表 -->
            <div id="comments-container" class="space-y-6">
                <!-- 评论会通过JS动态加载 -->
            </div>
        </div>
    </main>

    <!-- 底部 -->
    <footer class="bg-gray-800 text-white py-8">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
            <p>© 2025 我的个人博客 | 保持热爱，持续分享</p>
        </div>
    </footer>

    <!-- 评论功能JS -->
    <script>
        // 文章ID，用于区分不同文章的评论
        const articleId = 'article3';
        
        // 页面加载时获取并显示评论
        document.addEventListener('DOMContentLoaded', () => {
            loadComments();
            
            // 评论表单提交事件
            document.getElementById('comment-form').addEventListener('submit', (e) => {
                e.preventDefault();
                submitComment();
            });
        });
        
        // 加载评论
        function loadComments() {
            const comments = JSON.parse(localStorage.getItem(`comments_${articleId}`) || '[]');
            const container = document.getElementById('comments-container');
            const commentCount = document.getElementById('comment-count');
            
            // 更新评论数量
            commentCount.textContent = comments.length;
            
            // 清空容器
            container.innerHTML = '';
            
            // 如果没有评论，显示提示信息
            if (comments.length === 0) {
                container.innerHTML = '<p class="text-gray-500 italic">暂无评论，快来发表第一条评论吧！</p>';
                return;
            }
            
            // 渲染评论
            comments.forEach((comment, index) => {
                const commentElement = document.createElement('div');
                commentElement.className = 'bg-white p-6 rounded-lg shadow-sm';
                commentElement.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <h4 class="font-semibold text-gray-900">${escapeHTML(comment.name)}</h4>
                        <span class="text-gray-500 text-sm">${formatDate(comment.date)}</span>
                    </div>
                    <p class="text-gray-700 mb-4">${escapeHTML(comment.content)}</p>
                    <button class="text-red-500 text-sm hover:text-red-700 transition-colors delete-comment" 
                            data-index="${index}">
                        <i class="fa fa-trash-o mr-1"></i> 删除
                    </button>
                `;
                container.appendChild(commentElement);
            });
            
            // 为删除按钮添加事件监听
            document.querySelectorAll('.delete-comment').forEach(button => {
                button.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index || e.target.parentElement.dataset.index);
                    deleteComment(index);
                });
            });
        }
        
        // 提交评论
        function submitComment() {
            const nameInput = document.getElementById('name');
            const commentInput = document.getElementById('comment');
            
            const name = nameInput.value.trim();
            const content = commentInput.value.trim();
            
            if (!name || !content) {
                alert('请填写昵称和评论内容');
                return;
            }
            
            // 创建评论对象
            const comment = {
                name: name,
                content: content,
                date: new Date().toISOString()
            };
            
            // 从本地存储获取现有评论
            const comments = JSON.parse(localStorage.getItem(`comments_${articleId}`) || '[]');
            
            // 添加新评论到数组开头
            comments.unshift(comment);
            
            // 保存回本地存储
            localStorage.setItem(`comments_${articleId}`, JSON.stringify(comments));
            
            // 重新加载评论
            loadComments();
            
            // 清空表单
            nameInput.value = '';
            commentInput.value = '';
            
            // 显示成功提示
            alert('评论发表成功！');
        }
        
        // 删除评论
        function deleteComment(index) {
            if (confirm('确定要删除这条评论吗？')) {
                // 从本地存储获取现有评论
                const comments = JSON.parse(localStorage.getItem(`comments_${articleId}`) || '[]');
                
                // 删除指定索引的评论
                comments.splice(index, 1);
                
                // 保存回本地存储
                localStorage.setItem(`comments_${articleId}`, JSON.stringify(comments));
                
                // 重新加载评论
                loadComments();
            }
        }
        
        // 格式化日期
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
        
        // 防止XSS攻击，转义HTML特殊字符
        function escapeHTML(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
    </script>
</body>
</html>
